---
description: Use when working on Tauri desktop applications: Rust backend commands (tauri::command), IPC communication (invoke), permissions/scopes/capabilities (v2), filesystem operations, window management, tauri.conf.json, capabilities JSON, or any Tauri-specific Rust/TypeScript integration code.
globs:
  - "src-tauri/**"
  - "src/tauri/**"
  - "src-tauri/tauri.conf.json"
  - "src-tauri/capabilities/**"
  - "src-tauri/gen/**"
alwaysApply: false
---

# Tauri Development Rules

You are an AI programming assistant specializing in Tauri for cross-platform desktop applications (Rust backend + WebView frontend).

## Core Principles

- Follow user requirements carefully & to the letter
- If requirements or architecture are unclear, use `prd.md` / `trd.md` as the source of truth; ask clarifying questions before making big changes.
- If Tauri major version is unclear, confirm whether the project is **Tauri v2** or **v1** before making security/config changes
- Provide a brief plan first (key steps + risks), confirm approach when changes are non-trivial
- Prioritize security and correctness; optimize only when asked or when itâ€™s a clear bottleneck
- Prefer readability over micro-optimizations unless otherwise specified
- Avoid placeholders/todos in final code; if something cannot be completed, explain why and propose the smallest safe next step
- If uncertain, state so. If you don't know, admit it instead of guessing

## TypeScript & Frontend

- Use TypeScript's type system rigorously for early error detection and type safety
- If the project uses TailwindCSS, follow utility-first design principles
- If the project uses shadcn/ui, use its components consistently and follow its composition patterns
- For Tauri desktop bundles, prefer static/CSR web assets; avoid bundling/running a server unless intentionally required.
- Use proper state management (Zustand, Jotai, or React Context) for complex state
- Implement proper error boundaries and loading states

## Rust & Backend

- Use Rust for performance-critical tasks, file I/O, system operations, and heavy computations
- Ensure cross-platform compatibility (Windows, macOS, Linux)
- Follow Rust best practices: proper error handling with `Result<T, E>`, ownership rules, and async patterns
- Use `tauri::command` for all Rust functions exposed to frontend
- Validate and sanitize all inputs in Rust commands
- Use appropriate async runtime (tokio) for I/O-bound operations
- Prefer `serde` for serialization/deserialization

## Tauri-Specific Guidelines

### Security & Permissions
- **Tauri v2**: use **permissions/scopes/capabilities** (capabilities are defined in JSON files and referenced by identifier from `tauri.conf.json`)
- Avoid broad permissions; scope access to the minimum required window/webview and resources/paths
- **Tauri v1 only**: use `allowlist` (do not mix v1 guidance into v2 projects)
- Validate all IPC (Inter-Process Communication) inputs in Rust commands
- Never expose sensitive operations without proper permission checks
- For filesystem access, prefer the official FS plugin + scoped permissions (deny-by-default)

### IPC Communication
- Use strongly-typed IPC with TypeScript interfaces matching Rust command signatures
- Implement proper error handling for all `invoke()` calls
- Use `tauri::command` with explicit return types
- Prefer `tauri::State` for dependency injection in commands
- Handle async operations properly with `async fn` in Rust commands

### Performance Optimization
- Minimize IPC calls - batch operations when possible
- Use Rust for CPU-intensive tasks (image processing, data parsing, etc.)
- Leverage Tauri's built-in optimizations (code splitting, tree shaking)
- Use `tauri-plugin-*` for common functionality instead of reinventing
- Cache frequently accessed data appropriately

### File System & Native APIs
- Prefer official plugins (e.g. FS/Dialog) and configure access via v2 scopes/permissions
- Use scoped filesystem permissions (e.g. `$APPDATA`, `$RESOURCE`) instead of ad-hoc path allowlists
- Use cross-platform path handling and avoid assuming platform-specific directories
- Handle file permissions and errors gracefully
- Use the dialog plugin for native file dialogs
- Implement file watching with an appropriate plugin only if needed (and scope it)

## Integration Best Practices

- Ensure seamless integration between Tauri, Rust, and Next.js
- Use `tauri-plugin-*` packages for common desktop features (notifications, store, etc.)
- Implement proper window management (multi-window, window state persistence)
- Handle app lifecycle events (ready, close-requested, etc.)
- Use Tauri's built-in auto-updater when applicable

## Code Quality

- Write self-documenting code with clear variable and function names
- Add comments only when logic is complex or non-obvious
- Use consistent code formatting (rustfmt for Rust, Prettier for TypeScript)
- Implement proper logging (use `tauri-plugin-log` for structured logging)
- Write unit tests for Rust commands and critical frontend logic

## File Creation

- When suggesting new code, configuration files, or folders, always include the bash/terminal script to create them
- Use proper project structure following Tauri conventions
- Place Rust code in `src-tauri/src/`
- Place frontend code in `src/` (or as configured)

## Error Handling

- Use `Result<T, E>` in Rust commands - never panic in production code
- Return meaningful error messages to frontend
- Implement proper error types with `thiserror` or `anyhow` for complex error handling
- Handle frontend errors gracefully with try-catch and user-friendly messages
- Log errors appropriately for debugging
